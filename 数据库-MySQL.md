# 数据库-MySQL

>内容参考总结⾃⽹络资料，如⼩林coding、MySQL45讲

## 基础知识讲解

### MySQL基础

#### 主键、索引、外键

##### 什么是主键

主键是⼀列，其值可以唯⼀标识表中的每⼀⾏数据，每个表只能有⼀个主键，⽽且主键的值不能重复，也不能包含NULL值，通常⽤来保证数据的唯⼀性和⽤于在表中查找特定的⾏。

##### 主键、外键、索引的区别

**定义：**
主键：唯⼀标识⼀条记录，不允许重复，不允许为空
外键：外键是⼀个表中的字段，其值是另⼀个表的主键，⽤于建⽴两个表之间的关系。
索引：没有重复值，但可以有⼀个空值 ，⽤于快速查询到数据。

**作⽤：**
主键：⽤于唯⼀标识表中每⼀⾏的字段
外键：主要⽤于和其它表建⽴联系
索引：为了提⾼查询排序的速度

**区别：**
外键是⼀个表中的字段，它与另⼀个表的主键形成关联，⽤于建⽴表之间的关系。
主键和外键通常都与索引有关，但索引不⼀定是主键或外键。

#### MySQL表连接

##### 连接

将各个表中的记录都取出来进⾏依次匹配，将匹配后的结果发给客户端

##### 笛卡尔积

连接查询的结果中包含⼀个表的每⼀条记录与另⼀个表中每⼀条记录的组合，这样的查询结果就是笛卡尔积
⽐如表a有5条记录；表b有6条记录；a和b的笛卡尔积就是30

##### 连接过程

1、确定第⼀个需要查询的表，此表为`驱动表`
2、从驱动表中取每⼀条符合搜索条件的记录，到接下来的表中查找匹配的记录；驱动表之后的那个表就叫`被驱动表`

只需要访问驱动表⼀次，可能会多次访问被驱动表
每获得⼀条满⾜条件的驱动表记录，⻢上到被驱动表中寻找匹配的记录

##### 内连接

驱动表中的记录在被驱动表中找不到匹配的记录，那么驱动表的这条记录不会加⼊到最后的结果中

```sql
select * from 驱动表, 被驱动表;
select * from 驱动表 join 被驱动表;
select * from 驱动表 inner join 被驱动表;
select * from 驱动表 cross join 被驱动表;
```

##### 外连接

驱动表中的记录在被驱动表中找不到匹配的记录，也仍需要加⼊到最后结果中
左外连接：语句左侧的表为驱动表

```sql
select * from 驱动表 left join 被驱动表 on 连接条件;
```

右外连接：语句右侧的表为驱动表

```sql
select * from 被驱动表 right join 驱动表 on 连接条件;
```

对于内连接，驱动表和被驱动表的顺序可以更换；对于外连接，这个顺序不能随意更换

#### 过滤条件

##### where=

不论内外连接，只要是不符合 where ⼦句的记录都不会加⼊到最后的结果中

##### on

在内连接中与 where 等价；
在外连接中，如果驱动表中的记录在被驱动表中没有记录可以匹配，该驱动表记录仍会加⼊到结果中，对应的被驱动表字段以 null 填充

##### 嵌套循环连接

如果有3个表进⾏连接，那么表1和表2完成连接后的结果作为驱动表，将表3作为被驱动表进⾏连接查询

#### 执⾏⼀次 select 语句，发⽣了什么

![select语句执行过程](./image/select语句执行过程.png)

![MYSQL的逻辑架构图](./image/MYSQL的逻辑架构图.png)

MySQL 的架构共分为两层：Server 层和存储引擎层

- Server 层负责建⽴连接、分析和执⾏ SQL
- 存储引擎层负责数据的存储和提取, ⽀持 InnoDB、MyISAM、Memory 等多个存储引擎, 现在最常⽤的存储引擎是 InnoDB，其⽀持索引类型是 B+ 树索引。

##### 连接器：管理连接和权限验证

连接器跟客户端建⽴连接、获取权限、然后后⾯的权限逻辑判断都基于此时读取到的权限。

Mysql 会定期⾃动清理"空闲"连接，由参数 wait_timeout 控制的，默认值是 8 ⼩时。
由于建⽴连接⽐较复杂，所以尽量使⽤⻓连接，⽽不是 短连接(少量查询后，就断开连接)
但是，当`⻓连接`过多时，可能导致内存占⽤太⼤，被系统强⾏杀掉（OOM），会导致`MySQL`异常重启。

解决⽅案为:

- 定期断开⻓连接
- MySQL 5.7以后版本，可以通过执⾏ mysql_reset_connection 来重新初始化连接资源

##### 查询缓存

执⾏查询语句前，先看下查询缓存中是否有结果

- 如果有，则不必执⾏查询语句，直接取出缓存结果
- 如果没命中缓存，则执⾏查询语句，并将执⾏查询语句后的结果，放⼊查询缓存中

不建议使⽤查询缓存(当数据表频繁更新时，最新查询结果可能和查询缓存中存放的结果不⼀致)

>MySQL 8.0 开始，执⾏⼀条 SQL 查询语句，不会再⾛到查询缓存这个阶段了。

##### 解析SQL

你输⼊的是由多个字符串和空格组成的⼀条SQL语句，MySQL需要识别出⾥⾯的字符串分别是什么，代表什么。

- 词法分析：根据你输⼊的字符串识别出关键字出来
- 语法分析：根据词法分析的结果判断是否符合SQL语法，并构建SQL语法课

##### 执⾏SQL

分为三个阶段：预处理阶段、优化阶段、执⾏阶段

预处理阶段：判断表和字段是否存在

优化阶段：**将SQL查询语句的执⾏⽅案确定下来**，⽐如在表⾥⾯有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使⽤哪个索引, 或者在⼀个语句有多表关联（join）的时候，决定各个表的连接顺序。

执⾏阶段：MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进⼊了执⾏器阶段，开始执⾏语句（执⾏语句时，⾸先会判断当前⽤户是否有执⾏权限）。

#### 执⾏⼀次update语句，发⽣了什么

查询语句的流程，更新语句同样需要⾛⼀遍

1. 执⾏语句前先连接数据库
2. 数据库表有更新，跟表有关的查询缓存会失效，所以会清空之前的缓存结果
3. 分析器进⾏词法和语法解析，优化器进⾏优化，执⾏器负责执⾏，然后更新。

但是更新流程涉及到了两个重要的⽇志模块：`redo log(重做⽇志)`和`binlog(归档⽇志)`, 具体会在⽇志章节中讲解。

`redo log` 和 `binlog` 有什么不同？

- `redo log` 是 `InnoDB` 引擎特有的； `binlog`是`MySQL`的`Server`层实现的，所有引擎都可以使⽤。
`redo log`是物理⽇志，记录的是“在某个数据⻚上做了什么修改”；`binlog`是逻辑日志，记录的是这个语句的原始逻辑，⽐如“给`ID=2`这⼀⾏的`c`字段加`1`
`redo log`是循环写的，空间固定会⽤完；`binlog`是可以追加写⼊的。“追加写”是指`binlog`⽂件写到⼀定⼤⼩后会切换到下⼀个，并不会覆盖以前的⽇志。

### MySQL语句

⽬的：为了保证MySql服务器的安全，每个MySql的⽤户应该对他们需要的数据具有适当的访问权;
例如:

1. 多数⽤户只能够⽤到读写权限，只有少数⽤户能够创建表格和删除表格
2. ⼀些⽤户只能访问某个数据库⽽不能访问其他的数据库
3. ⼀些⽤户可以管理其他⽤户的账号，但⼤多数⼈不需要管理别⼈的账号

每个⽤户需要⽤到什么权限，就只给他们什么权限

如果每个⽤户的权限都很⾼，那数据库会变得⼗分危险，随时都需要⾯临很多误操作，所以要进⾏访问权限控制

#### ⽤户账号存储

在 MySql 下，所有的⽤户的账号，密码，对数据库的操作权限，都存储在 mysql 下（数据库的名字就叫 mysql）的 user 表格中。
user 表格有⼀个 user 属性，user 属性就是当前所有的⽤户名，通过以下操作可以查看当前 mysql 的⽤户⼀共有多少。

```sql
use mysql 
select user from user
```

![用户账号存储](./image/用户账号存储.png)

#### ⽤户账号管理

既然 mysql 中的 user 表格中存放着当前 mysql 的⽤户，那么新增⽤户只需要在 user 表中使⽤ insert 语句新增⼀条记录即可。
不过为了安全起⻅不建议这样做，mysql 数据库存放着很重要的数据，这样直接对 mysql 数据库直接操作可能会伤害到 mysql 服务器。

##### 新增⽤户

新增⼀个⽤户的语法：

```sql
CREATE USER [user_name] IDENTIFIED BY [user_pwd]
```

例如：新增⽤户 zhangsan，pwd=123456

```sql
CREATE USER zhangsan IDENTIFIED BY '123456'
```

##### 修改⽤户名

修改⽤户名的语法：

```sql
RENAME USER [user_name] TO [new_user_name]
```

例如：例如将账号名从 zhangsan 改为 lisi

```sql
RENAME USER zhangsan TO lisi
```

##### 修改⽤户密码

修改⽤户密码语法

```sql
SET PASSWORD FOR [user_name] = Password('[new_pwd]')
```

这⾥使⽤ password 函数对新密码进⾏加密。
如果不指定⽤户名：

```sql
SET PASSWORD = Password('[new_pwd]')
```

默认为修改当前登陆的⽤户的密码。
例如：修改 lisi 账号的密码：

```sql
SET PASSWORD FOR lisi = Password('135790')
```

##### ⽤户账号删除

删除⽤户账号语法：

```sql
DROP USER [user_name]
```

例如：删除 lisi 的账号

```sql
DROP USER lisi
```

如果mysql版本低于mysql5，需要先revoke⽤户所有的权限，才能删除账号。更⾼版本则可以⼀次性删除权限和账号。

##### ⽤户权限控制

###### 查看⽤户权限

刚创建的的⽤户是没有任何权限的，使⽤以下语法查看某⽤户所拥有的权限：

```sql
SHOW GRANTS FOR [user_name]
```

![查看用户权限](./image/查看用户权限.png)

⽽`GRANT USAGE ON *.* TO 'lS'@'%'`则代表了⽤户`ls`没有任何权限。

###### ⽤户授权

给⽤户授权的语法：

```sql
GRANT [权限名] ON [数据库名].[表名] TO [⽤户名]
```

例如：⽤户 'ls' 查找权限 select

![用户授权](./image/用户授权.png)

从表格中可以看到`ls`新增的权限。

###### 撤销授权

撤销⽤户权限的语法：

```sql
REVOKE [权限名] ON [数据库名].[表名] FROM [⽤户名]
```

收回⽤户`ls`查找权限`select`

![撤销授权](./image/撤销授权.png)

从表格中可以看初 ls 新增的权限消失了

### 索引

#### 什么是索引

索引：索引的出现其实就是为了提⾼数据查询的效率，就像书的⽬录⼀样
MySQL 在查询⽅⾯主要就是**两种⽅式**：

1. 全表扫描（⼀个⼀个挨个找）
2. 根据索引检索

#### 索引操作

##### 创建索引

```sql
create index 索引名 on 表名(列名);
# 也可以有多个列名构成索引（即，组合索引）
```

##### 删除索引

```sql
drop index 索引名 on 表名;
```

#### 怎么查看⼀个SQL语句是否使⽤了索引进⾏检索

在 SQL 语句前，添加 explian 关键字

- 当`type=ALL`时，表示使⽤ 全表查询（未使⽤索引）
- 当`type=RES`时，表示使⽤索引

#### 索引有哪些类别

- 按「数据结构」分类：B+tree索引、Hash索引、Full-text索引。
- 按「物理存储」分类：聚簇索引（主键索引）、⼆级索引（辅助索引）。
- 按「字段特性」分类：主键索引、唯⼀索引、普通索引、前缀索引。
- 按「字段个数」分类：单列索引、联合索引。

##### 按照数据结构分类

- 哈希表：使⽤ `key-value` 对存储数据 ，可能存在 hash 冲突（多个 value 对应同⼀个 key）
  - 优点：key ⽆序，插⼊数据时⽆需维护顺序（直接在最后⼀个元素后追加，即可），效率较⾼；
  - 缺点：因为不是有序的，所以哈希索引做区间查询的速度是很慢 
  - 适⽤场景：适⽤于只有等值查询的场景，⽽不适⽤频繁 区间查找
- 有序数组：
  - 优点：等值查询 和 区间查询 性能都挺6 （有序数组 适合 查询） 
  - 缺点：有序数组不适合 频繁 增/删 记录的场景 （但是，有序数组不适合 增/删）
  - 等值查询使⽤⼆分（前提是，有序 + 顺序存储），查询时间复杂度 O(log N)
  - 区间查询先⽤ ⼆分查找 “左边界”（不存在的时，则找第⼀个⽐ 它⼤的记录） ，然后，再向右扫描，直⾄⼤于右边界
  - 适⽤场景：有序数组只适⽤于静态存储引擎，在 等值查询 和 范围（区间）查询 场景中的性能⾮常优秀
- ⼆叉搜索树
  - BST 是为了 保留了 “有序数组” 查询（⼆分，O(logN)）性能好的优点，同时解决“有序数组” 不适合 增/删的缺点
  - BST 查询的时间复杂度：O(log N) ，但是，为了维持 O(log(N)) 的查询复杂度，就需要保持这棵树是平衡⼆叉树。（维护 BST 是 AVL 的时间复杂度也是 O(log(N))）
  - ⼆叉树是搜索效率最⾼的，但是实际上⼤多数的数据库存储却并不使⽤⼆叉树。其原因是，索引不⽌存在内存中，还要写到磁盘上
- N叉树
  - ![N叉树](./image/N叉树.png)
  - 为了让⼀个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使⽤⼆叉树，⽽是要使⽤ “N 叉”树（N 取决于数据块的⼤⼩）。即，通过使⽤ N 叉树 来降低 树的⾼度，即 减少读取磁盘的次数（IO是很慢的），提⾼查询效率 ⭐
  - N 叉树特点：
    - 折中 考虑了 “查询性能” 和 “读取磁盘的次数”，⼴泛应⽤于 数据库引擎中
    - MySQL 中，索引是在存储引擎层实现的，⽽且不同存储引擎的索引的⼯作⽅式并不⼀样。⽽即使多个存储引擎⽀持同⼀种类型的索引，其底层的实现也可能不同。

下⾯以InnoDB 为例，和你分析⼀下其中的索引模型

###### InnoDB 的索引模型

InnoDB 使⽤了 B+ 树索引模型，每⼀个索引在 InnoDB ⾥⾯对应⼀棵 B+ 树

假设建表语句如下，则对应的 2 棵 索引树（主键 ⾃动创建⼀颗；字段 k 创建 ⼀颗索引树），如下所示

```sql
create table T
(
    id int primary key, # 主键 ⾃动创建索引
    k int not null,
    name varchar(16),
    index (k)
) # 给字段 k 条件 索引
 
engine=InnoDB;
```

![InnoDB的索引组织结构](./image/InnoDB的索引组织结构.png)

##### 按照存储分类

根据叶⼦节点的内容，索引类型分为主键索引（聚簇索引）和⼆级索引（辅助索引）：

- 主键索引的 B+Tree 的叶⼦节点存放的是实际数据，所有完整的⽤户记录都存放在主键索引的 B+Tree 的叶⼦节点⾥；
- ⼆级索引的 B+Tree 的叶⼦节点存放的是主键值，⽽不是实际数据。

###### 主键查询和⼆级索引查询

主键查询：直接在 主键索引 所在的 B+ 树中查询，然后直接返回查询到的叶⼦节点（此时，叶⼦节点⾥⾯就是整⾏记录）

⼆级索引查询：⾸先，在普通索引所在的 B+ 树中，查询到待查询记录的 主键； 然后，再根据这些查到的 主键，执⾏ “主键查询” （即，回表）

基于⾮主键索引的查询需要多扫描⼀棵索引树。因此，我们在应⽤中应该尽量使⽤主键查询。

不过当查询的数据是能在⼆级索引的 B+Tree 的叶⼦节点⾥查询到，这时就不⽤再查主键索引查，这种在⼆级索引的 B+Tree 就能查询到结果的过程就叫作「覆盖索引」

由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使⽤覆盖索引是⼀个常⽤的性能优化⼿段。

##### 按照字段特性分类

- 主键索引：建⽴在主键字段上的索引，⼀张表最多只能有⼀个主键索引，不允许有空值。
- 唯⼀索引：建⽴在 UNIQUE 字段上的索引，⼀张表可以有多个唯⼀索引，索引列的值必须唯⼀，但是允许有空值。
- 普通索引：建⽴在普通字段上的索引
- 前缀索引：对字符类型字段的前⼏个字符建⽴的索引，⽽不是在整个字段上建⽴的索引，可以减⼩索引的⼤⼩，适⽤于较⻓列值的情况。

##### 按照字段个数分类

- 单列索引：建⽴在单列上的索引称为单列索引，⽐如主键索引；
- 联合索引：由多个列组合⽽成的索引。适⽤于多列的查询条件

#### 什么是最左匹配原则

通过将多个字段组合成⼀个索引，该索引就被称为联合索引。
使⽤联合索引时，存在**最左匹配原则**，也就是按照最左优先的⽅式进⾏索引的匹配。
最左匹配原则要求查询条件中的列应该从索引的最左边的列开始，并且不能跳过中间的列。如果查询条件不按照索引的顺序进⾏匹配，那么索引可能会失效。

举个例⼦：

- 如果查询条件为`WHERE column1 = 'value1'`，那么索引可以被有效使⽤。
- 如果查询条件为`WHERE column1 = 'value1' AND column2 = 'value2'`，同样索引可以被有效使⽤。
- 但如果查询条件为`WHERE column2 = 'value2'`或`WHERE column2 = 'value2' AND column3 = 'value3'`，则最左匹配原则不成⽴。

最左匹配时在遇到范围查询（如 >、<）的时候，就会停⽌匹配，范围查询的字段可以⽤到联合索引，但是范围查询字段的后⾯的字段⽆法⽤到联合索引。

#### 索引下推

![索引示意图](./image/索引示意图.png)

那些不符合最左前缀的部分，会怎么样呢？
⽐如，执⾏如下语句时候，则存在不符合最左前缀的部分：

```sql
select * from tuser
where name like '张 %'
and age=10
and ismale=1;
```

根据前缀索引规则，这个语句在搜索索引树的时候，只能⽤ “张”，找到第⼀个满⾜条件的记录 ID3
然后在 MySQL 5.6 之前，只能从 ID3 开始⼀个个回表，到主键索引上找出数据⾏，再对⽐字段值。
⽽ MySQL 5.6 引⼊了索引下推优化(index condition pushdown)
**可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满⾜条件的记录，减少回表次数。**

![无索引下推执行流程](./image/无索引下推执行流程.png)
![索引下推执行流程](./image/索引下推执行流程.png)

由图3可知，本例中`⽆索引优化`时，需要回表`4`次；
图4中，采⽤索引下推优化，直接在索引遍历的过程中，过滤了不符合条件的记录（ID3、ID6），只⽤回表`2`次

#### 索引区分度

索引区分度表示某个字段不同值的个数占整个表的⽐例，建⽴联合索引时，要把区分度⼤的字段排在前⾯。

#### 建⽴索引的注意事项

- 索引不是越多越好，虽然索引会提⾼ select 效率，但是也降低了insert以及update的效率
- 数据量⼩的表不需要建⽴索引，会增加额外的索引开销 
- 不经常使⽤的列不要建⽴索引 
- 频繁更新的列不要建⽴索引，会影响更新的效率

#### 索引的优缺点

优点：

- 使⽤索引可以⼤⼤加快数据的检索速度（⼤⼤减少检索的数据量），这也是创建索引的最主要的原因。
- 但是注意使⽤索引不⼀定能够提⾼查询性能，因为如果数据库的数据量不⼤，那么使⽤索引也不⼀定能够带来很⼤提升。其余⼤多数情况下，索引查询⽐全表扫描要快。
- 通过创建唯⼀性索引，可以保证数据库表中每⼀⾏数据的唯⼀性。

缺点：

- 空间消耗，⼀个索引对应的就是⼀棵 B+树，每⼀个节点都是⼀个 16KB ⼤⼩的⻚。占⽤的空间较⼤。
- 创建索引和维护索引需要耗费许多时间，当对表中的数据进⾏增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执⾏效率。

#### 什么时候需要创建索引

- 频繁⽤于查询的列需要创建索引
- ⼤表：对于很⼤的表，建⽴索引可以提⾼查询速度
- 唯⼀性要求：主键列和唯⼀性约束的列会⾃动创建唯⼀索引，但如果查询中经常包含唯⼀性条件，可以额外创建唯⼀性索引。
- 连接表的外键列：为外键列创建索引可以提⾼连接的效率。
- 频繁使⽤排序和分组的列：如果某列经常⽤于 ORDER BY 或 GROUP BY ⼦句可以创建索引

#### 什么时候不需要创建索引

- ⼩表：在⼩表上，索引不会带来显著的性能提升，还会增加维护开销。
- 经常进⾏更新的字段不需要创建索引
- 很少⽤于查询的字段
- 字段中存在⼤量重复数据，不需要创建索引，⽐如性别字段

#### 索引优化的⽅法

- 前缀索引优化：使⽤某个字段中字符串的前⼏个字符建⽴索引，从⽽减⼩索引字段⼤⼩
- 覆盖索引优化：从⼆级索引中可以查询得到记录，避免回表
- 主键索引最好是⾃增的；这样每次插⼊⼀条新记录，都是追加操作，不需要重新移动数据，⽽使⽤⾮⾃增主键会导致插⼊主键的索引值是随机的，这可能会插⼊到现有数据⻚的某个位置，导致其他数据的移动，造成⻚分裂。
- 避免过多的索引

#### 索引什么时候会失效

使⽤左或者左右模糊匹配：⽐如 LIKE '%abc' 这样的查询会导致索引失效。
在索引列上使⽤函数或表达式： 索引列上参与计算，索引失效

```sql
SELECT * FROM table WHERE UPPER(column) = 'VALUE';
```

- 在 WHERE ⼦句中，如果在 OR 前的条件列是索引列，⽽在 OR 后的条件列不是索引列，那么索引会失效。
- 违背最左匹配原则，索引失效
- 数据分布不均匀： 如果数据分布不均匀，例如某个索引列的⼤多数值都相同，选择性降低，导致索引失效。
- 隐式类型转换： 如果查询中的条件涉及到隐式类型转换，例如将字符串与数字⽐较，索引可能⽆法被使⽤。

#### 为什么使⽤B+树索引

- B+树的⾮叶⼦节点不存放实际的记录数据，仅存放索引，所以**数据量相同的情况下，相⽐存储即存索引⼜存记录的 B 树，B+树的⾮叶⼦节点可以存放更多的索引，因此 B+ 树可以⽐ B 树更「矮胖」，查询底层节点的磁盘 I/O次数会更少。**
- B+ 树有⼤量的冗余节点（所有⾮叶⼦节点都是冗余索引），这些冗余索引让 B+ 树在插⼊、删除的效率都更⾼，⽐如删除根节点的时候，不会像 B 树那样会发⽣复杂的树的变化；
- B+ 树叶⼦节点之间⽤链表连接了起来，有利于范围查询，⽽ B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。

### 事务

思维导图：

![事务隔离](./image/事务隔离.png)

MySQL原⽣引擎MyISAM不⽀持事务，所以被InnoDB取代。

#### 事务的四⼤特性 ACID

ACID（Atomicity、Consistency、Isolation、Durability，即原⼦性、⼀致性、隔离性、持久性）

##### 原⼦性

事务是⼀个不可分割的⼯作单元，要么完全执⾏，要么完全不执⾏。如果在事务执⾏的过程中发⽣了错误，系统会撤销事务中已经执⾏的操作，将数据库恢复到事务开始前的状态。原⼦性是通过 undo log（回滚⽇志） 来保证的。

##### ⼀致性

确保事务将数据库从⼀个⼀致的状态转变为另⼀个⼀致的状态。事务执⾏的结果必须满⾜数据库的完整性约束和规则，保持数据库的⼀致性。⼀致性则是通过持久性+原⼦性+隔离性来保证的。

##### 隔离性

多个事务并发执⾏时，每个事务都不能看到其他事务的中间状态。每个事务都应该感觉就像它是唯⼀在数据库上运⾏的事务⼀样。防⽌了多个事务之间的相互⼲扰。隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的。

##### 持久性

⼀旦事务被提交，其结果将永久保存在数据库中，即使系统发⽣故障。即使系统发⽣崩溃，事务的结果也不应该丢失，持久性是通过`redo log(重做⽇志)`来保证的。
